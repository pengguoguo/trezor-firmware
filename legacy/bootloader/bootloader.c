/*
 * This file is part of the Trezor project, https://trezor.io/
 *
 * Copyright (C) 2014 Pavol Rusnak <stick@satoshilabs.com>
 *
 * This library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <string.h>

#include <libopencm3/cm3/scb.h>
#include <libopencm3/stm32/gpio.h>
#include <libopencm3/stm32/rcc.h>

#include "bootloader.h"
#include "buttons.h"
#include "layout.h"
#include "memory.h"
#include "oled.h"
#include "rng.h"
#include "setup.h"
#include "signatures.h"
#include "usb.h"
#include "util.h"

//#include "crypto.h"
#include "AccHw_config.h"
#include "AccHw_crypto.h"

void layoutFirmwareFingerprint(const uint8_t *hash) {
  char str[4][17] = {0};
  for (int i = 0; i < 4; i++) {
    data2hex(hash + i * 8, 8, str[i]);
  }
  layoutDialog(&bmp_icon_question, "Abort", "Continue", "Compare fingerprints",
               str[0], str[1], str[2], str[3], NULL, NULL);
}

bool get_button_response(void) {
  do {
    delay(100000);
    buttonUpdate();
  } while (!button.YesUp && !button.NoUp);
  return button.YesUp;
}

void show_halt(const char *line1, const char *line2) {
  layoutDialog(&bmp_icon_error, NULL, NULL, NULL, line1, line2, NULL,
               "Unplug your Trezor,", "reinstall firmware.", NULL);
  shutdown();
}

void show_unplug(const char *line1, const char *line2) {
  layoutDialog(&bmp_icon_ok, NULL, NULL, NULL, line1, line2, NULL,
               "You may now", "unplug your Trezor.", NULL);
}

static void show_unofficial_warning(const uint8_t *hash) {
  layoutDialog(&bmp_icon_warning, "Abort", "I'll take the risk", NULL,
               "WARNING!", NULL, "Unofficial firmware", "detected.", NULL,
               NULL);

  bool but = get_button_response();
  if (!but) {  // no button was pressed -> halt
    show_halt("Unofficial firmware", "aborted.");
  }

  layoutFirmwareFingerprint(hash);

  but = get_button_response();
  if (!but) {  // no button was pressed -> halt
    show_halt("Unofficial firmware", "aborted.");
  }

  // everything is OK, user pressed 2x Continue -> continue program
}

static void __attribute__((noreturn)) load_app(int signed_firmware) {
  // zero out SRAM
  memset_reg(_ram_start, _ram_end, 0);

  jump_to_firmware((const vector_table_t *)FLASH_PTR(FLASH_APP_START),
                   signed_firmware);
}

static void bootloader_loop(void) {
  oledClear();
  oledDrawBitmap(0, 0, &bmp_logo64);
  if (firmware_present_new()) {
    oledDrawStringCenter(90, 10, "Trezor", FONT_STANDARD);
    oledDrawStringCenter(90, 30, "Bootloader", FONT_STANDARD);
    oledDrawStringCenter(90, 50,
                         VERSTR(VERSION_MAJOR) "." VERSTR(
                             VERSION_MINOR) "." VERSTR(VERSION_PATCH),
                         FONT_STANDARD);
  } else {
    oledDrawStringCenter(90, 10, "Welcome!", FONT_STANDARD);
    oledDrawStringCenter(90, 30, "Please visit", FONT_STANDARD);
    oledDrawStringCenter(90, 50, "trezor.io/start", FONT_STANDARD);
  }
  oledRefresh();

  usbLoop();
}

const uint8_t Message_RSAEncDec[] =
  {
    'h','e','l','l','o','w','o','r','l','d'
  };

const uint8_t Modulus_RSAEncDec[] = {
		0x5A,0xB5,0x96,0x7E,0x8A,0xE5,0xA0,0xB6,0xD5,0x84,0x35,0xB1,0xD9,0x31,0xF1,0xC5,
		0x82,0xF0,0xFC,0xBB,0x3B,0xA1,0x43,0xD6,0xD5,0x43,0x8B,0xF0,0x9C,0x36,0xBE,0x61,
		0xD4,0x6E,0x48,0xFD,0x5A,0xCB,0x5A,0x17,0x74,0x6D,0x2D,0x3B,0x47,0x04,0x42,0x1D,
		0xE5,0x9E,0x16,0x9E,0xCE,0xB4,0x0E,0x9D,0xCF,0xF6,0xEE,0x0A,0x77,0xBE,0x52,0xB0,
		0x8F,0xB2,0xF4,0xFF,0xAF,0x25,0x5A,0xA5,0xE5,0x2A,0xD6,0x75,0xDB,0xC8,0x88,0x22,
		0xD6,0x41,0x60,0x06,0xDC,0x59,0x01,0xAE,0xEE,0x88,0xBD,0xCE,0xF6,0xEB,0x04,0xD5,
		0xD7,0xF8,0xBF,0xCB,0xAB,0x80,0x36,0x75,0x2F,0x1F,0x86,0xEA,0xC5,0xF3,0x69,0x27,
		0x34,0x5A,0xEE,0xA3,0x2B,0x6D,0x31,0x21,0xFC,0xA4,0x66,0xFC,0xC1,0x02,0xEB,0x18,
		0x79,0x3D,0x98,0xB2,0xC0,0xFC,0x71,0x09,0xA0,0x3D,0xA0,0x83,0xA1,0x33,0x0B,0xDD,
		0x81,0x6F,0x0F,0x96,0xA0,0x2B,0xF2,0xDE,0x64,0x23,0xA6,0x47,0xA8,0xD5,0x0A,0x8E,
		0xD5,0xE8,0x02,0xF9,0xEB,0xD1,0xFF,0xC2,0x2C,0xFE,0xAB,0x46,0x19,0x37,0xF6,0x62,
		0xA8,0xC4,0xBE,0x5E,0x22,0x37,0x8C,0x83,0xF0,0x3B,0xF4,0xAC,0xE5,0x50,0x31,0xB0,
		0x41,0xEF,0xAC,0xFB,0x45,0xEE,0x0A,0x19,0xEE,0xA5,0x54,0x13,0x35,0xB5,0x39,0xA1,
		0xE3,0x11,0x48,0x51,0xFA,0x66,0xAE,0xDC,0xC7,0xB5,0x78,0x9C,0xC5,0xB3,0x09,0xD6,
		0x02,0xEA,0x5C,0xBA,0x9C,0xBD,0x14,0x10,0x2C,0x5B,0x14,0xEF,0x98,0x19,0x58,0xCB,
		0xC4,0x57,0xE4,0xCE,0xFF,0xB0,0xB4,0xAA,0x47,0xEF,0xBC,0x8A,0xDE,0x95,0xB8,0xD5
};

const uint8_t PublicExponent_RSAEncDec[] = {
		0x01, 0x00, 0x01
};

const uint8_t PrivateExponent_RSAEncDec[] =
  {
		    0x1b,0xcc,0x52,0x56,0x6d,0x52,0x79,0xb2,0x0e,0x34,0xfa,0x0f,0x8a,0xb4,0x17,
		    0x97,0xa3,0xcd,0x1e,0x66,0x72,0x9b,0xb5,0x22,0x7d,0x30,0xba,0x0d,0xfe,0x91,
		    0x78,0x3e,0x9a,0xcf,0x41,0x67,0x03,0x10,0x16,0x87,0xe1,0x92,0x23,0xae,0x6a,
		    0xd1,0x0f,0x42,0x02,0x40,0x34,0x46,0x6e,0xaa,0x17,0x60,0x9d,0x7e,0xda,0xec,
		    0x32,0x4e,0x0d,0x21,0x36,0xa8,0x6d,0x14,0x7e,0x24,0x40,0x67,0x5e,0x97,0x86,
		    0x29,0x90,0x35,0x20,0x23,0x2c,0xed,0xd3,0xf3,0xc6,0x4b,0x30,0x8c,0xdf,0x64,
		    0xe0,0x66,0x30,0x9d,0x4d,0x5a,0x0b,0x59,0x9b,0xcd,0x5a,0xbd,0x6b,0xf2,0xf5,
		    0x81,0xff,0xe2,0xaa,0xcf,0x31,0x86,0x66,0x31,0x07,0xb8,0xd1,0x72,0x21,0x00,
		    0x7d,0x60,0x14,0x7f,0x98,0xd6,0xc0,0x1c,0xdd,0xd0,0x6c,0xbe,0x3a,0xbc,0x45,
		    0x96,0x4e,0x7c,0xe2,0x76,0xd6,0x27,0xa2,0x36,0x63,0xad,0x99,0x17,0xa3,0xe0,
		    0x4f,0x91,0x62,0x36,0xd7,0x0c,0xa0,0xa7,0x81,0xe4,0xf3,0xcd,0x84,0xb5,0x61,
		    0x21,0xbc,0xfc,0xf6,0x99,0x57,0x82,0xa2,0xea,0x62,0x06,0x09,0x5e,0x70,0xb8,
		    0x9b,0x25,0x8b,0x88,0x96,0x3a,0x4a,0xe3,0xd5,0x0c,0x57,0xde,0x87,0x9c,0x9a,
		    0xce,0xe9,0xce,0x3c,0x5a,0x82,0x47,0x02,0xc5,0x92,0x1a,0x0a,0x24,0x3b,0x83,
		    0x69,0xcf,0xd5,0xdd,0x14,0x7b,0xc9,0x76,0x41,0x75,0x00,0xdd,0x1c,0x33,0x8f,
		    0x32,0x93,0xf5,0xcc,0x6c,0xdf,0x1a,0xd4,0xb4,0x0f,0x03,0xf9,0x81,0xda,0xee,
		    0x28,0x48,0x7d,0x95,0x7e,0x43,0x86,0xbf,0xf0,0xb9,0x2c,0xcb,0xd6,0xc9,0xe9,
		    0x81
  };


uint8_t preallocated_buffer_RSAEncDec[4096]; /* buffer required for internal allocation of memory */

AccHw_STM32CryptoLibVer_TypeDef AccHw_STM32CryptoLibVer;

uint8_t output_RSAEncDec[2048/8] = {0x00};
int32_t outputSize_RSAEncDec = 0;
uint8_t output_RSADecryt[2048/8] = {0x00};

AccHw_RSApubKey_stt  P_pPubKey;
AccHw_RSAprivKey_stt PrivKey_st;

int32_t outputSize = 0;

int32_t Result = 0;

AccHw_RSAinOut_stt inOut_st;
membuf_stt         mb;

AccHw_RSAinOut_stt DeOut_st;

int main(void) {
#ifndef APPVER
  setup();

  mb.mSize = sizeof(preallocated_buffer_RSAEncDec);
  mb.mUsed = 0;
  mb.pmBuf = preallocated_buffer_RSAEncDec;

  /* Fill the RSAinOut_stt */
  inOut_st.pmInput    = Message_RSAEncDec;
  inOut_st.mInputSize = sizeof(Message_RSAEncDec);
  inOut_st.pmOutput = output_RSAEncDec;

  AccHw_STM32_GetCryptoLibrarySettings(&AccHw_STM32CryptoLibVer);

  P_pPubKey.mExponentSize = sizeof(PublicExponent_RSAEncDec);
  P_pPubKey.mModulusSize  = sizeof(Modulus_RSAEncDec);
  P_pPubKey.pmExponent    = (uint8_t *)PublicExponent_RSAEncDec;
  P_pPubKey.pmModulus     = (uint8_t *)Modulus_RSAEncDec;

  PrivKey_st.mExponentSize   = sizeof(PrivateExponent_RSAEncDec);
  PrivKey_st.mModulusSize    = sizeof(Modulus_RSAEncDec);
  PrivKey_st.pmExponent      = (uint8_t *)PrivateExponent_RSAEncDec;
  PrivKey_st.pmModulus       = (uint8_t *)Modulus_RSAEncDec;

  Result = AccHw_RSA_PKCS1v15_Encrypt(&P_pPubKey, &inOut_st,  &mb);

  DeOut_st.pmInput = inOut_st.pmOutput;
  DeOut_st.pmOutput = output_RSADecryt;
  DeOut_st.mInputSize = 256;//sizeof(inOut_st.pmOutput);

  Result = AccHw_RSA_PKCS1v15_Decrypt(&PrivKey_st,&DeOut_st,&outputSize,&mb);

  while(1)
  {
	  ;
  }

#endif
  __stack_chk_guard = random32();  // this supports compiler provided
                                   // unpredictable stack protection checks
#ifndef APPVER
  memory_protect();
  oledInit();
#endif

  mpu_config_bootloader();

#ifndef APPVER
  bool left_pressed = (buttonRead() & BTN_PIN_NO) == 0;

  if (firmware_present_new() && !left_pressed) {
    oledClear();
    oledDrawBitmap(40, 0, &bmp_logo64_empty);
    oledRefresh();

    const image_header *hdr =
        (const image_header *)FLASH_PTR(FLASH_FWHEADER_START);

    uint8_t fingerprint[32] = {0};
    int signed_firmware = signatures_new_ok(hdr, fingerprint);
    if (SIG_OK != signed_firmware) {
      show_unofficial_warning(fingerprint);
    }

    if (SIG_OK != check_firmware_hashes(hdr)) {
      show_halt("Broken firmware", "detected.");
    }

    mpu_config_off();
    load_app(signed_firmware);
  }
#endif

  bootloader_loop();

  return 0;
}
